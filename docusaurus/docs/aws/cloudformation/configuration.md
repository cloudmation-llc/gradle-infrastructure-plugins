---
id: cf-config
title: CloudFormation Configuration
sidebar_label: Configuration
---

import useBaseUrl from '@docusaurus/useBaseUrl';

Building on the services provided by the [global configuration](../global-config), the CloudFormation plugin can be further customized by adding a `cloudformation` block to an `aws` block as demonstrated below:

```groovy
aws {
    cloudformation {
        capabilities = [""] // Set capabilities to be used for the stack deployment
        failOnEmptyChangeset = false
        parameterOverrides = [:] // A key-value map of parameter overrides provided to the stack at deployment
        roleArn = "" // IAM role that CloudFormation will assume for deployment
    }
}
```

| Property | Default Value | Description
| ---- | ---- | ----
| `capabilities` | None | For certain cases, you will need to set IAM capabilities. See the [create stack API reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_CreateStack.html).
| `failOnEmptyChangeset` | `false` | If `true`, a changeset that is created for a stack that results in no resource changes will cause the build to fail. `false` ignores this situation, and allows the build to succeed.
| `parameterOverrides` | None | Map of key-value parameters that override any default parameters specified in the template. _The same merging rules used for resource tags (see above) also apply to parameter overrides._
| `roleArn` | None | Set an IAM role that CloudFormation will assume for the stack deployment. [See AWS documentation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-servicerole.html).

## Customize Stack Naming

By default, a stack deployment task uses the filename of its template, and the name of its project to derive the stack name. For example, a template named `vpc.yml` in a subproject named `network` will have the stack name `network-vpc`.

There are ways to override this behavior:

**Override Stack Prefix**

Instead of using the project name to prefix the stack name, you can specify a custom prefix that all of the deploy tasks in the project will use.

```groovy
aws {
    cloudformation {
        stackPrefix = "super-awesome-network"
    }
}
```

Using the example above, if you have templates named `vpc.yml`, and `vpc-zone-a.yml`, then the respective stack names at deployment will be `super-awesome-network-vpc` and `super-awesome-network-vpc-zone-a`.

**Override Stack Name Per Task**

The configuration for automatically generated tasks can be changed even after they are created. For example, if you have a subproject named `network`, then there will be a `network.gradle` in the project directory. Open that file, and add an `afterEvaluate` block. You can use the task reconfiguration DSL to change the properties for any generated task.

```groovy
afterEvaluate {
    deployVpc.configure {
        aws {
            cloudformation {
                stackName = "super-awesome-vpc"
            }
        }
    }
}
```

## Customize Task Generation

If you want to customize the tasks that are automatically generated by the plugin, add a `taskGeneration` config block to the `cloudformation` block. **This is only supported at the subproject level.**

```groovy
aws {
    cloudformation {
        taskGeneration {
            group = "Some other group"    
        }
    }
}
```

### Task Naming

The plugin follow the Gradle convention of using camel casing for task names. The characters `-` `.` `_` and ` ` (space) are declared as delimiters which are fed into the camel case routine. Dashes (`-`) are very readable and encouraged for naming files and custom stacks.

### Task Grouping

Gradle tasks support a `group` property to logically group tasks together under categories. Using grouping provides for a neater appearance in tools that display lists of tasks such as when you run `gradle tasks` on the command line. This is recommended.

By default, the group will be set to `aws`, but you can change this to anything. For example you might consider grouping IAM tasks and network tasks separately.

### Including and Excluding Tasks

There could be use cases when you want to alter which tasks are generated by the plugin. For example, you want to use use the custom stacks feature _(see below)_ with a specific template file, and not have tasks generated automatically for that template. You can create rules that either use a [regular expression match](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html) on the task name, or you can provide a closure to use your own logic.

Include rules are evaluated first, and then exclude rules are evaluated after. You can call `include` or `exclude` as many times as you want. Rules are evaluated in creation order.

#### Exclude by Pattern

```groovy
aws {
    cloudformation {
        taskGeneration {
            exclude ".*VpcSubnet.*"   
        }
    }
}
```

#### Exclude by Closure

```groovy
aws {
    cloudformation {
        taskGeneration {
            exclude { taskName -> taskName == "someTaskYouWantToAvoid" }
        }
    }
}
```

#### Include by Pattern

```groovy
aws {
    cloudformation {
        taskGeneration {
            include "lint.*"   
        }
    }
}
```

#### Include by Closure

```groovy
aws {
    cloudformation {
        taskGeneration {
            include { taskName -> taskName == "someTaskYouWantToEnsureIsCreated" }
        }
    }
}
```

## Custom Stack Definition

The idea of using convention-over-configuration can be very convenient, but the default behavior may also generate tasks that you do not want, and you would like finer control over how a template is going to be deployed. Custom stacks skip the convention, and let you define the specific stacks to be deployed.

Add a `stacks` block to the `cloudformation` block. Below is a more complex example that sets a custom task group name, and uses a single template with parameterization to generate deployment tasks.

Note that name in quotes which defines each custom stack is used as part of the task name generation. See the _Task Naming_ section above for more detail on naming.

```groovy
aws {
    cloudformation {
        taskGeneration {
            group = "AWS Network"
        }

        stacks {
            "subnet-a" {
                stackName = "vpc-subnet-a"
                template = file("vpc-subnet.yml")
                parameterOverrides = [
                    "PrivateRange": "10.255.1.0/24",
                    "PublicRange": "10.255.251.0/24",
                    "RegionAzIndex": "0"]
            }

            "subnet-b" {
                stackName = "vpc-subnet-b"
                template = file("vpc-subnet.yml")
                parameterOverrides = [
                    "PrivateRange": "10.255.2.0/24",
                    "PublicRange": "10.255.252.0/24",
                    "RegionAzIndex": "1"]
            }

            "subnet-c" {
                stackName = "vpc-subnet-c"
                template = file("vpc-subnet.yml")
                parameterOverrides = [
                    "PrivateRange": "10.255.3.0/24",
                    "PublicRange": "10.255.253.0/24"
                    "RegionAzIndex": "2"]
            }

            "subnet-d" {
                stackName = "vpc-subnet-d"
                template = file("vpc-subnet.yml")
                parameterOverrides = [
                    "PrivateRange": "10.255.4.0/24",
                    "PublicRange": "10.255.254.0/24",
                    "RegionAzIndex": "3"]
            }
        }
    }
}
```

Running `gradle tasks` will display the tasks that are generated as a result.

<img
    alt="Screenshot of Custom Stacks"
    src={useBaseUrl('/img/screenshots/aws-cf-config-custom-tasks.png')} />